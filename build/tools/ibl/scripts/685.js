"use strict";(self.webpackChunk_babylonjs_texture_tools=self.webpackChunk_babylonjs_texture_tools||[]).push([[685],{8685:(e,t,n)=>{n.r(t),n.d(t,{ReadExrDataAsync:()=>se,_ExrTextureLoader:()=>le});var r=n(1137),a=n(4867);const o=4,i=4,l=1,s=2,c=8,u=65536,f=u>>3,w=14,h=65537,d=1<<w,p=d-1,y=59,b=63,v=2+b-y;var S,E;!function(e){e[e.NO_COMPRESSION=0]="NO_COMPRESSION",e[e.RLE_COMPRESSION=1]="RLE_COMPRESSION",e[e.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",e[e.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",e[e.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",e[e.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(S||(S={})),function(e){e[e.INCREASING_Y=0]="INCREASING_Y",e[e.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const g=function(){const e=new ArrayBuffer(4),t=new Float32Array(e),n=new Uint32Array(e),r=new Uint32Array(512),a=new Uint32Array(512);for(let e=0;e<256;++e){const t=e-127;t<-27?(r[e]=0,r[256|e]=32768,a[e]=24,a[256|e]=24):t<-14?(r[e]=1024>>-t-14,r[256|e]=1024>>-t-14|32768,a[e]=-t-1,a[256|e]=-t-1):t<=15?(r[e]=t+15<<10,r[256|e]=t+15<<10|32768,a[e]=13,a[256|e]=13):t<128?(r[e]=31744,r[256|e]=64512,a[e]=24,a[256|e]=24):(r[e]=31744,r[256|e]=64512,a[e]=13,a[256|e]=13)}const o=new Uint32Array(2048),i=new Uint32Array(64),l=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,n=0;for(;!(8388608&t);)t<<=1,n-=8388608;t&=-8388609,n+=947912704,o[e]=t|n}for(let e=1024;e<2048;++e)o[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)i[e]=e<<23;i[31]=1199570944,i[32]=2147483648;for(let e=33;e<63;++e)i[e]=2147483648+(e-32<<23);i[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(l[e]=1024);return{floatView:t,uint32View:n,baseTable:r,shiftTable:a,mantissaTable:o,exponentTable:i,offsetTable:l}}();function A(e,t){const n=new Uint8Array(e);let r=0;for(;0!=n[t.value+r];)r+=1;const a=(new TextDecoder).decode(n.slice(t.value,t.value+r));return t.value=t.value+r+1,a}function C(e,t){const n=e.getInt32(t.value,!0);return t.value+=o,n}function O(e,t){const n=e.getUint32(t.value,!0);return t.value+=o,n}function I(e,t){const n=e.getUint8(t.value);return t.value+=l,n}function R(e,t){const n=e.getUint16(t.value,!0);return t.value+=s,n}function U(e,t){const n=e[t.value];return t.value+=l,n}function M(e,t){let n;return n="getBigInt64"in DataView.prototype?Number(e.getBigInt64(t.value,!0)):e.getUint32(t.value+4,!0)+Number(e.getUint32(t.value,!0)<<32),t.value+=c,n}function x(e,t){const n=e.getFloat32(t.value,!0);return t.value+=i,n}function m(e,t){return function(e){const t=(31744&e)>>10,n=1023&e;return(e>>15?-1:1)*(t?31===t?n?NaN:1/0:Math.pow(2,t-15)*(1+n/1024):n/1024*6103515625e-14)}(R(e,t))}function P(e,t){return function(e){if(Math.abs(e)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");e=(0,a.Clamp)(e,-65504,65504),g.floatView[0]=e;const t=g.uint32View[0],n=t>>23&511;return g.baseTable[n]+((8388607&t)>>g.shiftTable[n])}(x(e,t))}function N(e,t,n,r){switch(n){case"string":case"stringvector":case"iccProfile":return function(e,t,n){const r=(new TextDecoder).decode(new Uint8Array(e).slice(t.value,t.value+n));return t.value=t.value+n,r}(e.buffer,t,r);case"chlist":return function(e,t,n){const r=t.value,a=[];for(;t.value<r+n-1;){const n=A(e.buffer,t),r=C(e,t),o=I(e,t);t.value+=3;const i=C(e,t),l=C(e,t);a.push({name:n,pixelType:r,pLinear:o,xSampling:i,ySampling:l})}return t.value+=1,a}(e,t,r);case"chromaticities":return function(e,t){return{redX:x(e,t),redY:x(e,t),greenX:x(e,t),greenY:x(e,t),blueX:x(e,t),blueY:x(e,t),whiteX:x(e,t),whiteY:x(e,t)}}(e,t);case"compression":return function(e,t){return I(e,t)}(e,t);case"box2i":return function(e,t){return{xMin:C(e,t),yMin:C(e,t),xMax:C(e,t),yMax:C(e,t)}}(e,t);case"lineOrder":return function(e,t){const n=I(e,t);return E[n]}(e,t);case"float":return x(e,t);case"v2f":return function(e,t){return[x(e,t),x(e,t)]}(e,t);case"v3f":return function(e,t){return[x(e,t),x(e,t),x(e,t)]}(e,t);case"int":return C(e,t);case"rational":return function(e,t){return[C(e,t),O(e,t)]}(e,t);case"timecode":return function(e,t){return[O(e,t),O(e,t)]}(e,t);case"preview":return t.value+=r,"skipped";default:return void(t.value+=r)}}function _(e){for(let t=1;t<e.length;t++){const n=e[t-1]+e[t]-128;e[t]=n}}function k(e,t){let n=0,r=Math.floor((e.length+1)/2),a=0;const o=e.length-1;for(;!(a>o||(t[a++]=e[n++],a>o));)t[a++]=e[r++]}const T=20000630;function z(e,t){if(e.getUint32(0,!0)!=T)throw new Error("Incorrect OpenEXR format");const n=e.getUint8(4),a=e.getUint8(5),o={singleTile:!!(2&a),longName:!!(4&a),deepFormat:!!(8&a),multiPart:!!(16&a)};t.value=8;const i={};let l=!0;for(;l;){const n=A(e.buffer,t);if(n){const a=A(e.buffer,t),o=N(e,t,a,O(e,t));void 0===o?r.V.Warn(`Unknown header attribute type ${a}'.`):i[n]=o}else l=!1}if(-5&a)throw new Error("Unsupported file format");return{version:n,spec:o,...i}}const F=32768,L=65535;function D(e,t,n,r,a){for(;n<e;)t=t<<8|U(r,a),n+=8;return{l:t>>(n-=e)&(1<<e)-1,c:t,lc:n}}function W(e,t,n,r){return{c:e=e<<8|U(n,r),lc:t+=8}}function B(e,t,n,r,a,o,i,l,s){if(e==t){if(r<8){const e=W(n,r,a,o);n=e.c,r=e.lc}let e=n>>(r-=8);if(e=new Uint8Array([e])[0],l.value+e>s)return null;const t=i[l.value-1];for(;e-- >0;)i[l.value++]=t}else{if(!(l.value<s))return null;i[l.value++]=e}return{c:n,lc:r}}const V=new Array(59);function Y(e){return 63&e}function G(e){return e>>6}function H(e,t,n,r,a,o){const i=n.value,l=O(t,n),s=O(t,n);n.value+=4;const c=O(t,n);if(n.value+=4,l<0||l>=h||s<0||s>=h)throw new Error("Wrong HUF_ENCSIZE");const u=new Array(h),f=new Array(d);if(function(e){for(let t=0;t<d;t++)e[t]={},e[t].len=0,e[t].lit=0,e[t].p=null}(f),function(e,t,n,r,a,o){const i=t;let l=0,s=0;for(;r<=a;r++){if(i.value-t.value>n)return;let c=D(6,l,s,e,i);const u=c.l;if(l=c.c,s=c.lc,o[r]=u,u==b){if(i.value-t.value>n)throw new Error("Error in HufUnpackEncTable");c=D(8,l,s,e,i);let u=c.l+v;if(l=c.c,s=c.lc,r+u>a+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)o[r++]=0;r--}else if(u>=y){let e=u-y+2;if(r+e>a+1)throw new Error("Error in HufUnpackEncTable");for(;e--;)o[r++]=0;r--}}!function(e){for(let e=0;e<=58;++e)V[e]=0;for(let t=0;t<h;++t)V[e[t]]+=1;let t=0;for(let e=58;e>0;--e){const n=t+V[e]>>1;V[e]=t,t=n}for(let t=0;t<h;++t){const n=e[t];n>0&&(e[t]=n|V[n]++<<6)}}(o)}(e,n,r-(n.value-i),l,s,u),c>8*(r-(n.value-i)))throw new Error("Wrong hufUncompress");!function(e,t,n,r){for(;t<=n;t++){const n=G(e[t]),a=Y(e[t]);if(n>>a)throw new Error("Invalid table entry");if(a>w){const e=r[n>>a-w];if(e.len)throw new Error("Invalid table entry");if(e.lit++,e.p){const t=e.p;e.p=new Array(e.lit);for(let n=0;n<e.lit-1;++n)e.p[n]=t[n]}else e.p=new Array(1);e.p[e.lit-1]=t}else if(a){let e=0;for(let o=1<<w-a;o>0;o--){const o=r[(n<<w-a)+e];if(o.len||o.p)throw new Error("Invalid table entry");o.len=a,o.lit=t,e++}}}}(u,l,s,f),function(e,t,n,r,a,o,i,l,s){let c=0,u=0;const f=i,h=Math.trunc(r.value+(a+7)/8);for(;r.value<h;){let a=W(c,u,n,r);for(c=a.c,u=a.lc;u>=w;){const i=t[c>>u-w&p];if(i.len){u-=i.len;const e=B(i.lit,o,c,u,n,r,l,s,f);e&&(c=e.c,u=e.lc)}else{if(!i.p)throw new Error("hufDecode issues");let t;for(t=0;t<i.lit;t++){const w=Y(e[i.p[t]]);for(;u<w&&r.value<h;)a=W(c,u,n,r),c=a.c,u=a.lc;if(u>=w&&G(e[i.p[t]])==(c>>u-w&(1<<w)-1)){u-=w;const e=B(i.p[t],o,c,u,n,r,l,s,f);e&&(c=e.c,u=e.lc);break}}if(t==i.lit)throw new Error("HufDecode issues")}}}const d=8-a&7;for(c>>=d,u-=d;u>0;){const e=t[c<<w-u&p];if(!e.len)throw new Error("HufDecode issues");{u-=e.len;const t=B(e.lit,o,c,u,n,r,l,s,f);t&&(c=t.c,u=t.lc)}}}(u,f,e,n,c,s,o,a,{value:0})}function X(e){return 65535&e}function Z(e){const t=X(e);return t>32767?t-65536:t}function j(e,t){const n=Z(e),r=Z(t),a=n+(1&r)+(r>>1);return{a,b:a-r}}function $(e,t){const n=X(e),r=X(t),a=n-(r>>1)&L;return{a:r+a-F&L,b:a}}function q(e,t,n,r,a,o,i){const l=i<16384,s=n>a?a:n;let c,u,f=1;for(;f<=s;)f<<=1;for(f>>=1,c=f,f>>=1;f>=1;){u=0;const i=u+o*(a-c),s=o*f,w=o*c,h=r*f,d=r*c;let p,y,b,v;for(;u<=i;u+=w){let a=u;const o=u+r*(n-c);for(;a<=o;a+=d){const n=a+h,r=a+s,o=r+h;if(l){let i=j(e[a+t],e[r+t]);p=i.a,b=i.b,i=j(e[n+t],e[o+t]),y=i.a,v=i.b,i=j(p,y),e[a+t]=i.a,e[n+t]=i.b,i=j(b,v),e[r+t]=i.a,e[o+t]=i.b}else{let i=$(e[a+t],e[r+t]);p=i.a,b=i.b,i=$(e[n+t],e[o+t]),y=i.a,v=i.b,i=$(p,y),e[a+t]=i.a,e[n+t]=i.b,i=$(b,v),e[r+t]=i.a,e[o+t]=i.b}}if(n&f){const n=a+s;let r;r=l?j(e[a+t],e[n+t]):$(e[a+t],e[n+t]),p=r.a,e[n+t]=r.b,e[a+t]=p}}if(a&f){let a=u;const o=u+r*(n-c);for(;a<=o;a+=d){const n=a+h;let r;r=l?j(e[a+t],e[n+t]):$(e[a+t],e[n+t]),p=r.a,e[n+t]=r.b,e[a+t]=p}}c=f,f>>=1}return u}function J(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function K(e){const t=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),n=new Uint8Array(function(e){let t=e.byteLength;const n=[];let r=0;const a=new DataView(e);for(;t>0;){const e=a.getInt8(r++);if(e<0){const o=-e;t-=o+1;for(let e=0;e<o;e++)n.push(a.getUint8(r++))}else{const o=e;t-=2;const i=a.getUint8(r++);for(let e=0;e<o+1;e++)n.push(i)}}return n}(t)),r=new Uint8Array(n.length);return _(n),k(n,r),new DataView(r.buffer)}function Q(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),r=new Uint8Array(n.length);return _(n),k(n,r),new DataView(r.buffer)}function ee(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),r=e.lines*e.channels*e.width,a=1==e.type?new Uint16Array(r):new Uint32Array(r);let o=0,i=0;const l=new Array(4);for(let t=0;t<e.lines;t++)for(let t=0;t<e.channels;t++){let t=0;switch(e.type){case 1:l[0]=o,l[1]=l[0]+e.width,o=l[1]+e.width;for(let r=0;r<e.width;++r)t+=n[l[0]++]<<8|n[l[1]++],a[i]=t,i++;break;case 2:l[0]=o,l[1]=l[0]+e.width,l[2]=l[1]+e.width,o=l[2]+e.width;for(let r=0;r<e.width;++r)t+=n[l[0]++]<<24|n[l[1]++]<<16|n[l[2]++]<<8,a[i]=t,i++}}return new DataView(a.buffer)}function te(e){const t=e.viewer,n={value:e.offset.value},r=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),a=new Uint8Array(f);let o=0;const i=new Array(e.channels);for(let t=0;t<e.channels;t++)i[t]={},i[t].start=o,i[t].end=i[t].start,i[t].nx=e.width,i[t].ny=e.lines,i[t].size=e.type,o+=i[t].nx*i[t].ny*i[t].size;const l=R(t,n),c=R(t,n);if(c>=f)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(l<=c)for(let e=0;e<c-l+1;e++)a[e+l]=I(t,n);const w=new Uint16Array(u),h=function(e,t){let n=0;for(let r=0;r<u;++r)(0==r||e[r>>3]&1<<(7&r))&&(t[n++]=r);const r=n-1;for(;n<u;)t[n++]=0;return r}(a,w),d=O(t,n);H(e.array,t,n,d,r,o);for(let t=0;t<e.channels;++t){const e=i[t];for(let n=0;n<i[t].size;++n)q(r,e.start+n,e.nx,e.size,e.ny,e.nx*e.size,h)}!function(e,t,n){for(let r=0;r<n;++r)t[r]=e[t[r]]}(w,r,o);let p=0;const y=new Uint8Array(r.buffer.byteLength);for(let t=0;t<e.lines;t++)for(let t=0;t<e.channels;t++){const e=i[t],n=e.nx*e.size,a=new Uint8Array(r.buffer,e.end*s,n*s);y.set(a,p),p+=n*s,e.end+=n}return new DataView(y.buffer)}var ne,re=n(350);!function(e){e[e.Float=0]="Float",e[e.HalfFloat=1]="HalfFloat"}(ne||(ne={}));class ae{}async function oe(e,t,n,r){const a={size:0,viewer:t,array:new Uint8Array(t.buffer),offset:n,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(e.compression){case S.NO_COMPRESSION:a.lines=1,a.uncompress=J;break;case S.RLE_COMPRESSION:a.lines=1,a.uncompress=K;break;case S.ZIPS_COMPRESSION:a.lines=1,a.uncompress=Q,await re.S0.LoadScriptAsync(ae.FFLATEUrl);break;case S.ZIP_COMPRESSION:a.lines=16,a.uncompress=Q,await re.S0.LoadScriptAsync(ae.FFLATEUrl);break;case S.PIZ_COMPRESSION:a.lines=32,a.uncompress=te;break;case S.PXR24_COMPRESSION:a.lines=16,a.uncompress=ee,await re.S0.LoadScriptAsync(ae.FFLATEUrl);break;default:throw new Error(S[e.compression]+" is unsupported")}a.scanlineBlockSize=a.lines;const o={};for(const t of e.channels)switch(t.name){case"R":case"G":case"B":case"A":case"Y":o[t.name]=!0,a.type=t.pixelType}let l=!1;if(o.R&&o.G&&o.B&&o.A)a.outputChannels=4,a.decodeChannels={R:0,G:1,B:2,A:3};else if(o.R&&o.G&&o.B)l=!0,a.outputChannels=4,a.decodeChannels={R:0,G:1,B:2,A:3};else if(o.R&&o.G)a.outputChannels=2,a.decodeChannels={R:0,G:1};else if(o.R)a.outputChannels=1,a.decodeChannels={R:0};else{if(!o.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");a.outputChannels=1,a.decodeChannels={Y:0}}if(1===a.type)switch(r){case ne.Float:a.getter=m,a.inputSize=s;break;case ne.HalfFloat:a.getter=R,a.inputSize=s}else{if(2!==a.type)throw new Error("Unsupported pixelType "+a.type+" for "+e.compression);switch(r){case ne.Float:a.getter=x,a.inputSize=i;break;case ne.HalfFloat:a.getter=P,a.inputSize=i}}a.blockCount=a.height/a.scanlineBlockSize;for(let e=0;e<a.blockCount;e++)M(t,n);const c=a.width*a.height*a.outputChannels;switch(r){case ne.Float:a.byteArray=new Float32Array(c),a.textureType=1,l&&a.byteArray.fill(1,0,c);break;case ne.HalfFloat:a.byteArray=new Uint16Array(c),a.textureType=2,l&&a.byteArray.fill(15360,0,c);break;default:throw new Error("Unsupported type: "+r)}let u=0;for(const t of e.channels)void 0!==a.decodeChannels[t.name]&&(a.channelLineOffsets[t.name]=u*a.width),u+=2*t.pixelType;return a.bytesPerLine=a.width*u,a.outLineWidth=a.width*a.outputChannels,"INCREASING_Y"===e.lineOrder?a.scanOrder=e=>e:a.scanOrder=e=>a.height-1-e,4==a.outputChannels?(a.format=5,a.linearSpace=!0):(a.format=6,a.linearSpace=!1),a}function ie(e,t,n,r){const a={value:0};for(let o=0;o<e.height/e.scanlineBlockSize;o++){const i=C(n,r)-t.dataWindow.yMin;e.size=O(n,r),e.lines=i+e.scanlineBlockSize>e.height?e.height-i:e.scanlineBlockSize;const l=e.size<e.lines*e.bytesPerLine&&e.uncompress?e.uncompress(e):J(e);r.value+=e.size;for(let n=0;n<e.scanlineBlockSize;n++){const r=o*e.scanlineBlockSize,i=n+e.scanOrder(r);if(i>=e.height)continue;const s=n*e.bytesPerLine,c=(e.height-1-i)*e.outLineWidth;for(let n=0;n<e.channels;n++){const r=t.channels[n].name,o=e.channelLineOffsets[r],i=e.decodeChannels[r];if(void 0!==i){a.value=s+o;for(let t=0;t<e.width;t++){const n=c+t*e.outputChannels+i;e.byteArray&&(e.byteArray[n]=e.getter(l,a))}}}}}}ae.DefaultOutputType=ne.HalfFloat,ae.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class le{constructor(){this.supportCascades=!1}loadCubeData(e,t,n,r,a){throw".exr not supported in Cube."}loadData(e,t,n){const a=new DataView(e.buffer),o={value:0},i=z(a,o);oe(i,a,o,ae.DefaultOutputType).then((e=>{ie(e,i,a,o);const r=i.dataWindow.xMax-i.dataWindow.xMin+1,l=i.dataWindow.yMax-i.dataWindow.yMin+1;n(r,l,t.generateMipMaps,!1,(()=>{const n=t.getEngine();t.format=i.format,t.type=e.textureType,t.invertY=!1,t._gammaSpace=!i.linearSpace,e.byteArray&&n._uploadDataToTextureDirectly(t,e.byteArray,0,0,void 0,!0)}))})).catch((e=>{r.V.Error("Failed to load EXR texture: ",e)}))}}async function se(e){const t=new DataView(e),n={value:0},a=z(t,n);try{const e=await oe(a,t,n,ne.Float);return ie(e,a,t,n),e.byteArray?{width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,data:new Float32Array(e.byteArray)}:(r.V.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(e){r.V.Error("Failed to load EXR data: ",e)}return{width:0,height:0,data:null}}}}]);