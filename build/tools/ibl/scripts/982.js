"use strict";(self.webpackChunk_babylonjs_texture_tools=self.webpackChunk_babylonjs_texture_tools||[]).push([[982],{982:(e,t,i)=>{i.r(t),i.d(t,{iblIcdfPixelShader:()=>r});var n=i(9610);i(3325);const o="iblIcdfPixelShader",c="precision highp sampler2D;\n#include<helperFunctions>\nvarying vec2 vUV;\n#ifdef IBL_USE_CUBE_MAP\nuniform samplerCube iblSource;\n#else\nuniform sampler2D iblSource;\n#endif\nuniform sampler2D scaledLuminanceSampler;uniform int iblWidth;uniform int iblHeight;uniform sampler2D cdfx;uniform sampler2D cdfy;float fetchLuminance(vec2 coords) {\n#ifdef IBL_USE_CUBE_MAP\nvec3 direction=equirectangularToCubemapDirection(coords);vec3 color=textureCubeLodEXT(iblSource,direction,0.0).rgb;\n#else\nvec3 color=textureLod(iblSource,coords,0.0).rgb;\n#endif\nreturn dot(color,LuminanceEncodeApprox);}\nfloat fetchCDFx(int x) { return texelFetch(cdfx,ivec2(x,0),0).x; }\nfloat bisectx(int size,float targetValue) {int a=0,b=size-1;while (b-a>1) {int c=a+b>>1;if (fetchCDFx(c)<targetValue)\na=c;else\nb=c;}\nreturn mix(float(a),float(b),\n(targetValue-fetchCDFx(a))/(fetchCDFx(b)-fetchCDFx(a))) /\nfloat(size-1);}\nfloat fetchCDFy(int y,int invocationId) {return texelFetch(cdfy,ivec2(invocationId,y),0).x;}\nfloat bisecty(int size,float targetValue,int invocationId) {int a=0,b=size-1;while (b-a>1) {int c=a+b>>1;if (fetchCDFy(c,invocationId)<targetValue)\na=c;else\nb=c;}\nreturn mix(float(a),float(b),\n(targetValue-fetchCDFy(a,invocationId)) /\n(fetchCDFy(b,invocationId)-fetchCDFy(a,invocationId))) /\nfloat(size-1);}\nvoid main(void) {ivec2 cdfxSize=textureSize(cdfx,0);int cdfWidth=cdfxSize.x;int icdfWidth=cdfWidth-1;ivec2 currentPixel=ivec2(gl_FragCoord.xy);vec3 outputColor=vec3(1.0);if (currentPixel.x==0) {outputColor.x=0.0;} else if (currentPixel.x==icdfWidth-1) {outputColor.x=1.0;} else {float targetValue=fetchCDFx(cdfWidth-1)*vUV.x;outputColor.x=bisectx(cdfWidth,targetValue);}\nivec2 cdfySize=textureSize(cdfy,0);int cdfHeight=cdfySize.y;if (currentPixel.y==0) {outputColor.y=0.0;} else if (currentPixel.y==cdfHeight-2) {outputColor.y=1.0;} else {float targetValue=fetchCDFy(cdfHeight-1,currentPixel.x)*vUV.y;outputColor.y=max(bisecty(cdfHeight,targetValue,currentPixel.x),0.0);}\nvec2 size=vec2(textureSize(scaledLuminanceSampler,0));float highestMip=floor(log2(size.x));float normalization=texture(scaledLuminanceSampler,vUV,highestMip).r;float pixelLuminance=fetchLuminance(vUV);outputColor.z=pixelLuminance/(2.0*PI*normalization);gl_FragColor=vec4(outputColor,1.0);}\n";n.l.ShadersStore[o]||(n.l.ShadersStore[o]=c);const r={name:o,shader:c}}}]);